//                                                  Set

// Объекты Set — это встроенные объекты JavaScript, определенные начиная с ECMAScript 2015.

// Set - представляет собой коллекцию значений. Значение в наборе может встречаться только один раз. Позволяет хранить уникальные значения любого типа, будь то примитивные значения или ссылки на объекты.

// Равенство значений основано на алгоритме SameValueZero. (Раньше использовалось SameValue , которое рассматривалось 0 и -0 как разные. Проверьте совместимость браузера). NaN считается тем же, что и NaN(хотя NaN !== NaN), а все остальные значения считаются равными в соответствии с семантикой оператора ===

const mySet1 = new Set(); //=> Set(0) {}

// add() - метод добавляет уникальные(те которых в нем еще нет) элементы в конец Сета
mySet1.add(1);              //=> Set(1) { 1 }
mySet1.add(5);              //=> Set(2) { 1, 5 }
mySet1.add(5);              //=> Set(2) { 1, 5 }
mySet1.add("some text");    //=> Set(3) { 1, 5, 'some text' }
mySet1.add({ a: 1, b: 2 }); //=> Set(4) { 1, 5, 'some text', { a: 1, b: 2 } }
mySet1.add({ a: 1, b: 2 }); //=> Set(5) { 1, 5, 'some text', { a: 1, b: 2 }, { a: 1, b: 2 } } // тк объекты разные

// Можно перебирать элементы набора в порядке вставки. Порядок вставки соответствует порядку, в котором каждый элемент был вставлен в набор методом add(), если в наборе еще не было идентичного элемента.

// size - возвращает число элементов в сете
mySet1.size; //=> 5

// has() - метод проверяет наличие значения в наборе, он в среднем быстрее, чем проверка большинства элементов, которые ранее были добавлены в набор. Например, он в среднем быстрее, чем Array.includes метод, когда length массива, равно значению size сета.
mySet1.has(1);                         //=> true
mySet1.has(3);                         //=> false
mySet1.has(Math.sqrt(25));             //=> true
mySet1.has("Some Text".toLowerCase()); //=> true

// values() и keys() (алиасы) - возвращает новый объект-итератор, который возвращает значения для каждого элемента Set-а в порядке вставки
mySet1.values(); //=> [Set Iterator] { 1, 5, 'some text', { a: 1, b: 2 }, { a: 1, b: 2 } }

// delete() - удвляет заданный параметром элемент из сета и возвращает true, если он там был иначе false
mySet1.delete(5); //=> true
mySet1;           //=> Set(4) { 1, 'some text', { a: 1, b: 2 }, { a: 1, b: 2 } }

// clear() - удаляет все элементы из сета
const mySet3 = new Set([1, 2, 3]);
mySet3.clear();
mySet3; //=> Set(0) {}


// Конвертировать Set object в Array object
Array.from(mySet1); //=> [ 1, 'some text', { a: 1, b: 2 }, { a: 1, b: 2 } ]
[...mySet1];        //=> [ 1, 'some text', { a: 1, b: 2 }, { a: 1, b: 2 } ]

// Конвертировать Array object в Set object (удаляет повторяющиеся элементы из массива)
new Set([1, 1, 2, 3, 4, 3, 2]); //=> Set(4) { 1, 2, 3, 4 }

// Конвертировать строку в Set object (удаляет повторяющиеся элементы)
new Set("firefox"); // Set(6) { 'f', 'i', 'r', 'e', 'o', 'x' }



//                                         Циклы и итераторы для сетов

// for of
for (const item of mySet1) { item; }                  //=> 1, "some text", { "a": 1, "b": 2 }, { "a": 1, "b": 2 }
for (const item of mySet1.keys()) { item; }           //=> 1, "some text", { "a": 1, "b": 2 }, { "a": 1, "b": 2 }
for (const item of mySet1.values()) { item; }         //=> 1, "some text", { "a": 1, "b": 2 }, { "a": 1, "b": 2 }
// key и value для сета тоже самое
for (const [key, value] of mySet1.entries()) { key; } //=> 1, "some text", { "a": 1, "b": 2 }, { "a": 1, "b": 2 }

// forEach()
mySet2.forEach((value) => value); //=> 1, 2, 3, 4



//                                          Взаимодействия 2х сетов

// Пересечение(intersect) - общие элементы 2х сетов
new Set([...mySet1].filter((x) => mySet2.has(x)));  //=> Set(1) { 1 }

// Разница(difference) - объекты 1го сета которых нет во 2м
new Set([...mySet1].filter((x) => !mySet2.has(x))); //=> Set(3) { 'some text', { a: 1, b: 2 }, { a: 1, b: 2 } }















//
