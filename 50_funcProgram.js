//                                   Основы функционального программирования

// Функциональное программирование(ФП) - это одна из 2х парадигм программирования(другая ООП). Менее популярно с точки зрения бизнеса чем ООП.
// Не все языки могут применить ФП, есть чисто ФП-языки(Haskell, Lisp, F#), есть мультипарадигменные языки(JS, Scala) и есть чисто ООПшные языки

// ФП основано на том, что мы управляем функциями как математическими функциями(ламбда вычисления), из чего и следуют все дальнейшие свойства и принципы функционального программирования

// Четыре основных концепции вытекающие из ФП:
// 1. Декларативный подход в написании кода
// 2. Чистые функции
// 3. Иммутабельность(неизменяемость) - подход работы с данными при котором данные не изменяются
// 4. Функции первого класса и функции высшего порядка. Дают гибкость в написании кода



//                                           Процедура и функция

// Процедура - это просто кусок/блок кода(подпрограмма), который чтото выполняет, набор заданных действий

// Функция имеет все свойства процедуры, но при этом чтото возвращает, например какоето значение, если его нет все равно будет возвращать например undefined(JS) nil(Ruby) итд

// В ФП мы работаем с функциями как с математическими функциями, те при одних и тех же переданных параметрах будет возвращаться всегдв один и тот же результат. Тоесть к функциям в ФП нужно относиться не как к набору действий, а как к резкльтату вычислений



//                                              Декларативность

// Код можно писать либо в 2х ситлях:
// 1. Императивный стиль - описываем действие(описываем как мы хотим чтото получить, те каждое действие ведущее к результату)
// 2. Декларативныфй ситль - описываем результат(описываем что мы хотим получить, те задача)

// Декларативность это свойство не только ФП, но и любого хорошего кода. Но у декларативного кода всеравно "под капотом" на уровне абстракций все равно будет императивный код


// Пример фунции в императивном стиле
function calcUsersAverageAgeByCountry(users, country) { // фильтруем, считаем средний возраст
  const filteredUsers = [];
  for (let i = 0; i < users.length; i++) {
    if (users[i].country === country) filteredUsers.push(users[i]);              // фильтруем по стране
  }
  let allAge = 0;
  for (let i = 0; i < filteredUsers.length; i++) { allAge += filteredUsers[i]; } // считаем общий возраст
  return allAge / filteredUsers.length;
}

// Для того чтобы привести функцию к декларативному стилю нужно создать еще один слой абстрации и вынести каждое действие в отдельную функцию
function filterByCountry(users, country) { // Отдельная функция фильтрует по стране("подкапотный" имеративный код)
  const filteredUsers = [];
  for (let i = 0; i < users.length; i++) { if (users[i].country === country) filteredUsers.push(users[i]); }
  return filteredUsers;
}
function calcUsersAverageAge(users) { // Отдельная функция считает средний возраст("подкапотный" имеративный код)
  let allAge = 0;
  for (let i = 0; i < users.length; i++) { allAge += users[i].age; }
  return allAge / users.length;
}
function calcUsersAverageAgeByCountry(users, country) { // функция(более высокий слой абстракции) с декларативным кодом
  const filteredUsers = filterByCountry(users, country);
  return calcUsersAverageAge(filteredUsers);
}

// Но можно сделать код Декларативным и без использования абстракций из новых функций, при помощи встроенных функций. Встроенные функции языков это результат влияния ФП
function calcUsersAverageAgeByCountry(users, country) {
  const filteredUsers = users.filter(user => user.country === country);
  return filteredUsers.reduce((avg, user) => avg + user.age, 0);
}

// Еще более декларативный выриант с выносом функций-аргументов для стандарьтных функций как функций общего назначения, которые могут преобразовывать данные по разным полям.
const filterUsersByField = (field, value) => (user) => user[field] === value;  // возвращает функцию-фргумент фильтр по любому полю
const sumUsersByField = (field) => (sum, user) => sum + user[field]; // возвращает функцию аргумент суммирующую по любому полю
function calcUsersSumFieldByField(users, fieldForFilter, valueForFilter, fieldForSum) {
  return users.filter(filterUsersByField(fieldForFilter, valueForFilter))
              .reduce(sumUsersByField(fieldForSum), 0);
}
const users = [
  {money:1000, age:20, country:'RU'}, {money:5000, age:50, country:'RU'},
  {money:100, age:100, country:'UA'}, {money:300, age:200, country:'UA'}
]
console.log(calcUsersSumFieldByField(users, 'country', 'RU', 'age'));  //=> 70
console.log(calcUsersSumFieldByField(users, 'country', 'UA', 'money')); //=> 400



//                                        Чистые функции и сайд эффекты



//                                        Иммутабельность(неизменяемость)



//                                            Функции первого класса



//                                            Функции высшего порядка



//                                              Композиция/конвейер



//                                        Частичное применение и каррирование



//                                                     Chaining



//                                                    Контейнеры



//                                          Функторы и аппликативные функторы



//                                                      Монады



//                                             Спецификация Fantasy-Land
