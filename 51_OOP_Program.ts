//                            Объектно ориентированная парадигма программирования

// Например есть человек и любого человека можно охарактеризовать свойствами/характеристиками: имя и возраст, этот набор/описание свойств в ООП называется классом
// Конкретный экземпляр, представитель класса называется объектом, для него каждое свойство класса имеет конкретное значение, например Вася, которому 27 лет
// Характеристики объекта называются свойствами, а действия, которые может совершать объект, называются методами, например Вася может ходить, говорить итд

// Класс Прямоугольник
class Rectangle {
  // У него есть 2 свойства: ширина и высота
  width;
  height;
  // У любого класса есть конструктор - это специальный метод, содержащий набор инструкций, которые вызываются при создании нового объекта. Обычно в конструкторе свойствам объекта присваиваются какие-то значения
  constructor(w, h) {
    this.width = w;
    this.height = h;
  }
  // метод экземпляра, манипулирующий свойствами, тут считающий площадь, перемножая значения свойств
  calcArea() {
    return this.width * this.height;
    // this - возвращает объект от которого быдет вызван данный метод, соотв от него возьмем и свойства
  }
  // Каждый класс может включать в себя любое колличество свойств и методов, но хорошей практикой считается делать классы под конкретные задачи, только с теми свойствами и методами, которые для них необходимы
}
// Создаем новый объект и передаем аргументами значения для его свойств.
const rect = new Rectangle(w: 5, h: 10);
// Можем создать любое колличество объектов:
const rect2 = new Rectangle(w: 3, h: 9);
// От созданных объектов мы можем вызвать метод экземпляора
rect.calcArea()  //=> 50
rect2.calcArea() //=> 27


// ООП построена на 3х концепциях: инкапсуляция, наследование, полиморфизм



//                                            Инкапсуляция и сокрытие

// Инкапсуляция - сам класс является своего рода капсулой, которая содержит в себе свойства и методы для работы с этими свойствами, тоесть инкапсуляция позволяет все это объединить.

// Сокрытие - создание скрытуой части класса, например скрытые свойства и методы, которые нельзя вызвать вне тела класса. Для того чтобы делать методы или свойства публичными или приватными во многих языках существуют модификаторы доступа public и private

class Rectangle {
  // Сделаем свойства приватными, тоесть не сможем обратиться к ним извне класса. Нижнее почеркивание в имени свойства указывает на то что оно приватное - это некое соглашение в JS, TS и некоторых других языках.
  // Чаще всего все свойства делают приватными
  private _width;
  private _height;

  constructor(w, h) {
    this._width = w;
    this._height = h;
  }

  // Для того чтобы получить доступ к приватным свойствам, тоесть получать их или изменять создаются специальные методы - геттеры и сеттеры. Так же помимо возврата и изменения можно прописать в них доп логику
  get width() {
    return this._width;
  }
  // Если явно не указывать модификатор доступа для свойств или методов, то по умолчанию он будет public, но хорошей практикой бкдет указывать его явно:
  public set width(value) {
    if (value <= 0) this._width = 1;
    else this._width = value;
  }

  // Для свойства height сделали только геттер, тоесть изменять его мы не сможем
  get width() {
    return this._height;
  }
}

// Например класс БД, у которого свойства ЮРЛ и пользователь с паролем который подключается к БД, значения этих свойств мы присваивает от объекта внутри конструктора и создаем для них геттеры. При этом так же будет список таблиц, которые содержит в себе эта БД, изначально будет пустым массивом
class Database {
  private _url;
  private _username;
  private _password;
  private _tables;

  constructor(url, username, password) {
    this._url = url;
    this._username = username;
    this._password = password;
    this._tables = [];
  }

  // Чтобы добавлять таблицы в массив this._tables создадим отдельный метод, при этом менять этот массив напрямую мы не можем, а только при помощи данного метода
  public createNewTable(table) {
    this._tables.push(table);
  }
  // Чтобы удалить таблицы из массива тоже можно создать отдельный метод
  public clearTables() {
    this._tables = [];
  }

  get url() {
    return this._url;
  }
  get username() {
    return this._username;
  }
  get password() {
    return this._password;
  }
}



//                                                  Наследование

// Наследование - способ взаимодействия между классами, позволяет переиспользовать код, тк класс получает свойства и методы от родительского класса

// В большинстве языков программирование нет множественного наследования, тоесть не можем наследовать сразу от нескольких классов. В тех же языках где множественное наследование есть, например C++, класс наследник примет все свойства и методы от всех классов у которых он наследует.

// Создадим класс человека со свойствами, геттерами и сеттерами
class Person {
  private _name;
  private _age;

  constructor(name, age) {
    this._name = name;
    this._age = age;
  }

  get name() {
    return this._name;
  }
  set name(value) {
    this._name = value;
  }

  get age() {
    return this._age;
  }
  set age(value) {
    this._age = value;
  }
}

// Создадим класс работника, у которого должны быть теже свойства что у класса человека и еще свои собственные. Но для того чтобы не писать теже самые свойства используем наследование, те расширим класс работника от класса человека
class Employee0 extends Person {
  // Теперь класс Employee наследует свойства методы и конструктор у класса Person
}
// Соответсвенно мы можем создать объект с заданием значений унаследованных свойств
const employee0 = new Employee0(name: 'Vasya', age: 15);

// Добавим новые свойства в класс наследник
class Employee extends Person {
  private _inn;
  private _pasport_number;

  // Переопределяем конструктор, чтобы добавить значения новых свойств
  constructor(name, age, inn, pasport_number) {
    super(name, age); // значения старых свойств отправляем в родительский конструктор, который вызываем функцией super
    this._inn = inn; // и только потом задаем значения новых свойств
    this._pasport_number = pasport_number;
  }
}
// Соответсвенно мы можем создать объект с заданием значений и унаследованных и своих свойств
const employee = new Employee(name: 'Vasya', age: 15, inn: 68456, pasport_number: 65465456);

// Создадим класс разработчика, который будет наследовать уже от класса работника
class Developer extends Employee {
  private _level;

  constructor(name, age, inn, pasport_number, level) {
    super(name, age, inn, pasport_number); //
    this._level = level;
  }
}
// Соответсвенно мы можем создать объект с заданием значений и унаследованных и своих свойств
const developer = new Employee(name: 'Vasya', age: 15, inn: 68456, pasport_number: 65465456, level: 'MIDDLE');

// Таким образом с помощью наследования мы можем создавать целую иерархию классов, где каждый класс наследник перенимает свойства и методы родительского класса и может дополнительно обладать и своими собственными



//                                               Полиморфизм

// Полиморфизм - концепция ООП, которая позволяет одному и тому же фрагменту кода работать с разными типами данных. Возможно самый важный принцип ООП и на нем основаны почти все паттерны проектирования

// Выделяют 2 типа полиморфизма: параметрический полиморфизм (истинный) и ad-hoc полиморфизм (мнимый)


// 1. ad-hoc полиморфизм (мнимый). Например в классе Calculator есть 2 метода, которые называются одинаково, принимают одинаковые параметры, но они разных типов, 1й метод принимает числовой тип, а 2й строковый. В итоге при вызове как бы одного и того же метода в зависимости от типов передаваемых параметров, произведем или сложение чисел или конкатинацию строк. Происходит засчет перегрузки методов.
class Calculator {
  add(a :number, b :number): number {
    return a + b;
  }
  add(a :string, b :string): string {
    return a + b;
  }
}


// 2. Параметрический полиморфизм (истинный):

// Материнский класс имеет метод greeting
class Person {
  private _name;
  constructor(name, age) {
    this._name = name;
  }
  public greeting() {
    console.log(`Привет я человек, меня зовут ${this._name}`);
  }
}

// Класс наследник наследует метод greeting, но переопределим его, чтобы он выводил другое сообщение
class Employee extends Person {
  private _pasport_number;
  constructor(name, pasport_number) {
    super(name);
    this._pasport_number = pasport_number;
  }
  public greeting() {
    console.log(`Привет я работник, меня зовут ${this._name}, мой номер паспорта ${this._pasport_number}`);
  }
}

// Объекты и материнского класса и класса наследника могут использовать как бы один и тот же метод
const person = new Person(name: 'Vasya');
const employee = new Employee(name: 'Petya', pasport_number: 158786867);
person.greeting() //=> "Привет я человек, меня зовут Vasya"
employee.greeting() //=> "Привет я работник, меня зовут Petya, мой номер паспорта 158786867"

// Можем реализовать функцию
const personList: Person[] = [person, employee]; // указываем что массив типа Person без явного указания типов отдельных классов

function massGreeting(persons: Person[]) {
  for (let i = 0; i < persons.length; i++) {
    const person = persons[i];
    person.greeting()
    // одинаковым способом вызываем функцию с разной логикой для разных типов объектов это и есть полиморфизм
  }
}

massGreeting(personList)



//                                            Агрегация и композиция

// Агрегация и композиция - как и наследование это способы взаимодействия между классами

// Композиция - объект класса использует внутри себя объекты другого класса, все эти объекты не существуют отдельно от объекта, который их использует и создаются внутри него

// Агрегация - объект класса использует внутри себя объекты другого класса, некоторые из этих объектов могут существовать отдельно от объекта, который их использует и создаются вне него

class Engine { // Класс двигатель
  drive() {
    console.log(`Двигатель работает`);
  }
}

class Wheel { // Класс колесо
  drive() {
    console.log(`Колесо крутится`);
  }
}

class Biker { } // Класс байкер

class Moto { // Класс мотоцикл
  engine: Engine; // Свойсво типа Двигатель
  wheels: Wheel[]; // Массив типа Колесо
  biker: Biker;

  constructor(biker) {
    // Агрегация - объект передается в класс извне
    this.biker = biker;
    // Композиция - создаем объекты внутри класса
    this.engine = new Engine();
    this.wheels.push(new Wheel());
    this.wheels.push(new Wheel());
  }
  // Делегирование. Создадим метод drive у мотоцикла и внутри него происходит делегирование - те вызывается такой же метод у колес и двигателя
  drive() {
    this.engine.drive();
    for (let i = 0; i < this.wheels.length; i++) {
      this.wheels[i].drive(); //
    }
  }
}

// Создадим объект
const moto = new Moto(biker: new Biker());

// Теперь если удалим объет мотоцикла, то двигатель и колеса так же удалятся, а байкер нет



//                                    Абстрактные классы и интерфейсы

// Интерфейс - в нем описываются методы с параметрами их типами и типами возврата этих методов, но при этом нет реальзации этих методов. Интерфейс это как оглавление в книге, он описывает что нужно сделать, но не описывает как это нужно сделать. От интерфейса нельзя создать объект. Класс имплементирующий интерфейс должен реализовывать все методы, что есть в этом интерфейсе. Имплементировать один интерфейс могут разные классы, при этом реализация методов интерфейса может отличаться у каждого класса.
// Позволяют писать более гибкий код, с более гибким полиморфизмом и в первую очередь систему нужно проектировать на уровне интерфейсов
interface Client {
  connect(url:string):void;
  read():string;
  write(data:string):void;
}

// Абстрактный класс - похож на интерфейс, в нем можно объявлять абстрактные методы, которые будут аналогами методов интерфейса, те без реализации, но при этом можно создавать и обычные методы с какой-то реализацией. Класс который унаследует от абстрактного, унаследует обычные методы и должен будет реализовать абстрактные методы. Абстрактные классы используются существенно реже интерфейсов
abstract class Client {
  connect(url:string):void {
    // какаято логика
  }
  abstract read():string;
  abstract write(data:string):void;
}


// Пример использования интерфейсов:
interface Reader { // интерфейс 1
  read(url);
}

interface Writer { // интерфейс 2
  write(data);
}

class FileClient implements Reader, Writer { // класс может имплементировать несколько интерфейсов, тоесть реализовать методы из каждого из этих интерфейсов
  read(url) {
    // какая-то логика
  }
  write(data) {
    // какая-то логика
  }
}


// Пример использования интерфейсов 2:
// Создадим класс, с объектами которого бует работать класс, имплементирующий интерфейс ниже
class User {
  username: string;
  age: number;
}
// Можем создать другой класс с объектами которого бует работать другой класс имплементирующий интерфейс
class Car {
  carname: string;
}
// Создадим интерфейс Репозиторий с 4мя CRUD методами. Тк в классе в который имплементируем интерфейс методы ожидают аргументы, добавим в интерфейс обобщение/дженерик для типов принимаемых и возвращаемых данных - в данном случае тип T это чтото общее, какойто тип данных приходящий извне
interface Repository<T> {
  create: (obj: T) => T;
  get: () => T;
  delete: (obj: T) => T;
  update: (obj: T) => T;
}
// Создадим класс Юзер-Репозиторий, который имплементирует интерфейс репозитория и реализует его методы, так же добавим в таких же скобках тип данных, который будет использоваться везде где в интерфейсе есть тип T
class UserRepo implements Repository<User> {
  create(user: User): User {
    return database.query(INSERT ...);
  }
  get(): User {
    return undefined;
  }
  delete(user: User): User {
    return undefined;
  }
  update(user: User): User {
    return undefined;
  }
}
// Создадим другой класс Кар-Репозиторий, который тоже имплементирует интерфейс репозитория и реализует его методы, но уже с другим типом данных
class CarRepo implements Repository<Car> {
  create(user: Car): Car {
    return database.query(INSERT ...);
  }
  get(): Car {
    return undefined;
  }
  delete(user: Car): Car {
    return undefined;
  }
  update(user: Car): Car {
    return undefined;
  }
}

// Тоесть еще на этапе проектирования создаем интерфейс, в котором определяем какие должны быть методы, а потом подстраиваясь под этот интерфейс реализуем некоторые классы



//                               Паттерн Dependency injection (Внедрение зависимостей)

// Dependency injection (Внедрение зависимостей) - паттерн. Используется множеством фрэймворков например: Спринг, Ангуляр, НекстЖС
// Приложение разделено на слои:
// 1й слой отвечает за логику по работе с БД(получить, записать, обновить, удалить данные). У репозиторного слоя может быть несколько реализаций, наример для работы с МонгоДБ и для работы с ПостгрэSQL, тоесть в зависимости от неких условий мы работаем с одной или другой СУБД
// 2й слой это сервисный слой тоесть какая-то бизнес логика, в котором может быть что угодно, например работа с репозиторием, тоесть с 1м слоем. Если использует внутри себя репозиторий, то можно чтобы сервисний слой вообще не знал какой из репозиториев он использует. У него есть интерфейс к которому он обращается, получает какие-то данные из репозиторного слоя и ему не важно работает он с Монго или Постресс репозиторием. На уровне сервиса мы работаем с некоторым интерфейсрм в репозитории, а имплементацию/реализацию этого репозитория Моного или Постресс мы определяем гдето снаружи, например на уровне конфигурации, при этом чтобы изменить одну имплементацию на другую нам не нужно править сервисний слой и достаточно изменить кофигурацию

// Интерфейс Юзер-репозитория в котором описаны КРУД методы для работы БД с пользователями
interface UserRepo {
  getUsers: () => User[];
  // create:, delete:, update: остальные методы КРУД
}
// Реализация для работы с MongoDB, которая имплементирует интерфейс UserRepo
class UserMongoDBRepo implements UserRepo {
  // Метод получает пользователей из БД MongoDB
  getUsers(): User[] {
    console.log('Используем подключение к MongoDB и получаем пользователей');
    return [{age: 15, username: 'Пользователь из MongoDB'}];
  }
}
// Реализация для работы с Postgres, которая имплементирует интерфейс UserRepo
class UserPostgresRepo implements UserRepo {
  // Метод получает пользователей из БД Postgres
  getUsers(): User[] {
    console.log('Используем подключение к Postgres и получаем пользователей');
    return [{age: 15, username: 'Пользователь из Postgres'}];
  }
}
// Класс с бизнес логикой. Может внутри себя использовать репозитори MongoDB или Postgres
class UserService {
  userRepo: UserRepo; // Указываем, что в данном классе используем юзкр-репозиторий, но как тип указываем не конкретный класс(имплементацию), а сам интерфейс
  // Инициализируем это свойство через конструктор, тоесть принимаем репозиторий извне
  constructor(userRepo: UserRepo) {
    this.userRepo = userRepo;
  }
  // Внутри метода сервиса вызываем метод из репозитория, который возвращает нам список пользователей
  filterUserByAge(age: number) {
    counst users = this.userRepo.getUsers();
    // ... какая-то логика по фильтрации
    console.log(users);
  }
}
// Создадим объект UserService и передаем какой либо из репозиториев (имплементаций) в конструктор
const userService = new UserService(new UserMongoDBRepo())
userService.filterUserByAge(age: 15); //=> [{age: 15, username: 'Пользователь из MongoDB'}]
// Передадим в конструктор сервиса другую имплементацию для работы с Postgres
const userService = new UserService(new UserPostgresRepo())
userService.filterUserByAge(age: 15); //=> [{age: 15, username: 'Пользователь из Postgres'}]
// Тоесть мы измне определяем как будет работать сервис, передавая соответсвующий аргумент в конструктор, например для Монго, Постресс, потом решим хранить фаилы вообще в фаилах, для чего нам нужно просто передать соответсвующую имплементацию в конструктор сервиса



//                                                 Синглтон

// Синглтон - паттерн проектирования из банды 4х

// Для класса БД необходимо гарантировать, что будет создан лишь один объект, потому что несколько в нашем приложении быть не может, тк если ктото создаст еще один экземпляр БД, то будет уже 2 подключения
class Database {
  url: number;
  // Добавим приветное статичное(принадлежащее классу, а не объекту) поле, тк мы его нигде не инициализировали, то изначально оно является null
  private static instance: Database;

  constructor() {
    if (Database.instance) { // тоесть если эта переменная содержит не null, а объект БД, тоесть объект БД уже существует, то возвращаем этот объект
      return Database.instance;
    }
    // А если не существует, тогда инициализируем свойства, создаем объект БД и присваиваем его в переменную класса
    this.url = Math.random(); // проинициализируем свойство рандомным числом для примера
    Database.instance = this;
  }
}
// Создадим 2 объекта этого класса и выведем ЮРЛ каждого в консоль
const db1 = new Database();
const db2 = new Database();
// В итоге выведут ондно и тоже рандомное число и сколько объектов мы бы не создали, всегда это будет один и тот же объект
console.log(db1.url);
console.log(db2.url);













//
