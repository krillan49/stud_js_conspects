//                            Объектно ориентированная парадигма программирования

// Например есть человек и любого человека можно охарактеризовать свойствами/характеристиками: имя и возраст, этот набор/описание свойств в ООП называется классом
// Конкретный экземпляр, представитель класса называется объектом, для него каждое свойство класса имеет конкретное значение, например Вася, которому 27 лет
// Характеристики объекта дазываются свойствами, а действия, которые может совершать объект, называются методами, например Вася может ходить, говорить итд

// Класс Прямоугольник
class Rectangle {
  // У него есть 2 свойства: ширина и высота
  width;
  height;
  // У любого класса есть конструктор - это специальный метод, содержащий набор инструкций, которые вызываются при создании нового объекта. Обычно в конструкторе свойствам объекта присваиваются какие-то значения
  constructor(w, h) {
    this.width = w;
    this.height = h;
  }
  // Так же есть метод, манипулирующий свойствами, тут считающий площадь, перемножая значения свойств
  calcArea() {
    return this.width * this.height;
    // this - возвращает объект от которого быдет вызван данный метод, соотв от него возьмем и свойства
  }
  // Каждый класс может включать в себя любое колличество свойств и методов, но хорошей практикой считается делать классы под конкретные задачи, только с теми свойствами и методами, которые для них необходимы
}
// Создаем новый объект и передаем аргументами значения для его свойств.
const rect = new Rectangle(w: 5, h: 10);
// Можем создать любое колличество объектов:
const rect2 = new Rectangle(w: 3, h: 9);
// От созданных объектов мы можем вызвать метод экземпляора
rect.calcArea()  //=> 50
rect2.calcArea() //=> 27


// ООП построена на 3х концепциях: инкапсуляция, наследование, полиморфизм



//                                            Инкапсуляция и сокрытие

// Инкапсуляция - сам класс является своего рода капсулой, которая содержит в себе свойства и методы для работы с этими свойствами, тоесть инкапсуляция позволяет все это объединить.

// Сокрытие - позволяет создать скрытую часть класса, например скрытые свойства и методы, которые нельзя вызвать вне тела класса. Для того чтобы делать методв или свойства публичными или приватными во многих языках существуют модификаторы доступа public и private

class Rectangle {
  // Сделаем свойства приватными, тоесть не сможем обратиться к ним извне коасса. Нижнее почеркивание в имени свойства указывает на то что оно приватное - это некое соглашение в JS, TS и некоторых других языках.
  // Чаще всего все свойства делают приватными
  private _width;
  private _height;

  constructor(w, h) {
    this._width = w;
    this._height = h;
  }

  // Для того чтобы получить доступ к приватным свойствам, тоесть получать их или изменять создаются специальные методы - геттеры и сеттеры. Так же помимо возврата и изменения можно прописать в них доп логику
  get width() {
    return this._width;
  }
  // Если явно не указывать модификатор доступа для свойств или методов, то по умолчанию он будет public, но хорошей практикой бкдет указывать его явно:
  public set width(value) {
    if (value <= 0) this._width = 1;
    else this._width = value;
  }

  // Для свойства height сделали только геттер, тоесть изменять его мы не сможем
  get width() {
    return this._height;
  }
}

// Например класс БД, у которого свойства ЮРЛ и пользователь с паролем который подключается к БД, значения этих свойств мы присваивает от объекта внутри конструктора и создаем для них геттеры. При этом так же будет список таблиц, которые содержит в себе эта БД, изначально будет пустым массивом
class Database {
  private _url;
  private _username;
  private _password;
  private _tables;

  constructor(url, username, password) {
    this._url = url;
    this._username = username;
    this._password = password;
    this._tables = [];
  }

  // Чтобы добавлять таблицы в массив this._tables создадим отдельный метод, при этом менять этот массив на прямую мы не можем, а только при помощи данного метода
  public createNewTable(table) {
    this._tables.push(table);
  }
  // Чтобы удалить таблицы из массива тоже можно создать отдельный метод
  public clearTables() {
    this._tables = [];
  }

  get url() {
    return this._url;
  }
  get username() {
    return this._username;
  }
  get password() {
    return this._password;
  }
}



//                                                  Наследование

// В большинстве языков программирование нет множественного наследования, тоесть не можем наследовать сразу от нескольких классов. В тех же языках где множественное наследование есть, например C++, класс наследник примет все свойства и методы от всех классов у которых он наследует.

// Создадим класс человека со свойствами геттерами и сеттерами
class Person {
  private _name;
  private _age;

  constructor(name, age) {
    this._name = name;
    this._age = age;
  }

  get name() {
    return this._name;
  }
  set name(value) {
    this._name = value;
  }

  get age() {
    return this._age;
  }
  set age(value) {
    this._age = value;
  }
}

// Создадим класс работника, у которого должны быть теже свойства что у класса человека и еще свои собственные. Но для того чтобы не писать теже самые свойства используем наследование, те расширим класс работника от класса человека
class Employee0 extends Person {
  // Теперь класс Employee наследует свойства методы и конструктор у класса Person
}
// Соответсвенно мы можем создать объект с заданием значений унаследованных свойств
const employee0 = new Employee0(name: 'Vasya', age: 15);

// Добавим новых свойств в класс наследник
class Employee extends Person {
  private _inn;
  private _pasport_number;

  // Переопределяем конструктор, чтобы добавить значения новых свойств
  constructor(name, age, inn, pasport_number) {
    super(name, age); // значения старых свойств отправляем в родительский конструктор, который вызываем функцией super
    this._inn = inn; // и только потом задаем значения новых свойств
    this._pasport_number = pasport_number;
  }
}
// Соответсвенно мы можем создать объект с заданием значений и унаследованных и своих свойств
const employee = new Employee(name: 'Vasya', age: 15, inn: 68456, pasport_number: 65465456);

// Создадим класс разработчика, который будет наследовать уже от класса работника
class Developer extends Employee {
  private _level;

  constructor(name, age, inn, pasport_number, level) {
    super(name, age, inn, pasport_number); //
    this._level = level;
  }
}
// Соответсвенно мы можем создать объект с заданием значений и унаследованных и своих свойств
const developer = new Employee(name: 'Vasya', age: 15, inn: 68456, pasport_number: 65465456, level: 'MIDDLE');

// Таким образом с помощью наследования мы можем создавать целую иерархию классов, где каждый класс наследник перенимает свойства и методы родительского класса и может дополнительно обладать и своими собственными













//
