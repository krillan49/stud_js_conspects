// vanilla.js -  можно написать в резюмэ как шутку(на самом деле это просто js в виде псевдофрэймворка)

// Например в JS объектами являются не тольно массивы, но и обертки над примитивами, тк когда мы вызываем методы от примитивов, то вызываем их не от примитива, тк он не объект, а от объектной обертки.


// Функция кодирования пробельных и других символов URL-адресов
'http://www.codewars.com/users/' + encodeURIComponent("aaa "); //=> http://www.codewars.com/users/aaa%20

// перевод в формат денег ??
console.log((12345.6789).toLocaleString()); // 12 345,679

// eval()
console.log(eval('2 + 2')); //=> 4
console.log(eval(new String('2 + 2'))); //=> '2 + 2'
console.log(eval('2 + 2') === eval('4')); //=> true
console.log(eval('typeof "a"')) //=> string
console.log(eval('Math.sqrt(4)')) //=> 2





// о this:
String.prototype.method = function() {
  return this;
};
Number.prototype.method = function() {
  return this;
};
var str = "12";
var num = 12;
console.log( str.method() ); //=> [String: '12']
console.log( num.method() ); //=> [Number: 12]
// Это всего лишь собственные объекты; вы используете thisтак же, как и в обычной функции-прототипе.
// Обратите внимание, что вы действительно работаете с объектами: экземплярами, созданными с помощью «String», «Number» или какого-либо другого собственного конструктора. Вещи вроде "hello world"и 12.54не являются объектами, они примитивы. У них нет прототипов.
// Когда вы используете примитивный объект, как если бы он был объектом, среда выполнения автоматически повышает его до экземпляра объекта. Это происходит, когда вы используете примитивное значение с операторами .или [].
// Из таких объектов (экземпляров String, Number или Boolean) примитивное значение можно получить с помощью this.valueOf()











//
