// Итераторы и генераторы привносят концепцию итерации непосредственно в основной язык и предоставляют механизм настройки поведения циклов for...of.

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators



//                                                  Итераторы

// В JavaScript итератор — это объект, который определяет последовательность и, возможно, возвращаемое значение после ее завершения.

// Итераторы используются только по мере необходимости. Благодаря этому итераторы могут выражать последовательности неограниченного размера, например диапазон целых чисел от 0 до бесконечности.

// Создание пользовательских итераторов требует явно поддерживать их внутреннее состояние.

// Итератор — это любой объект, который реализует протокол Iterator, имея метод next(), который возвращает объект с двумя свойствами:
// value - cледующее значение в последовательности итераций.
// done - вернет true, если последнее значение в последовательности уже использовано. Если рядом с done присутствует value - это возвращаемое значение итератора.


// пример позволяет создать простой итератор диапазона, который определяет последовательность целых чисел от начала (включительно) до конца (исключительно), отстоящих друг от друга на шаг. Его окончательное возвращаемое значение — это размер созданной им последовательности, отслеживаемый переменной count.
function makeRangeIterator(start = 0, end = Infinity, step = 1) {
  let i = start, count = 0;

  const rangeIterator = { // те итератор это объект с методом next()
    next() {
      let res;
      if (i < end) { // тоесть если итерация еще не завершена
        res = { value: i, done: false };
        i += step;
        count++;
        return res; // возвращается при каждом вызове next() пока итерация не завершена
      }
      return { value: count, done: true }; // возвращается при каждом вызове next() когда итерация завершена
    }
  };

  return rangeIterator;
}

const iter = makeRangeIterator(1, 10, 2); // получаем наш итератор
console.log(iter); //=> { next: [Function: next] }

// После создания объект итератора можно явно повторять, неоднократно вызывая next().
let res = iter.next(); // итерируем вызывая метод next()
console.log(res); //=> { value: 1, done: false }
while (!res.done) {
  console.log(res.value); //=> 1 3 5 7 9
  res = iter.next();
}
// После получения завершающего значения дополнительные вызовы next() должны продолжать возвращать {done: true}.
console.log(res); //=> { value: 5, done: true }
console.log(res.value); //=> 5  // те возвращено 5 чисел, которые заняли интервал между: от 0 до 10


// Совсем кастомный итератор или это лучше в замыкания ??
function makeLooper(str) {
  let i = 0;
  return function() {
    let res = str[i];
    i = i == str.length - 1 ? 0 : i + 1;
    return res;
  }
}
let abc = makeLooper('abc');
console.log(abc()); //=> 'a'
console.log(abc()); //=> 'b'
console.log(abc()); //=> 'c'
console.log(abc()); //=> 'a'



//                                           Функции - генераторы

// Функции-генераторы предоставляют мощную альтернативу пользовательским итераторам: они позволяют определить итерационный алгоритм, написав одну функцию, выполнение которой не является непрерывным.

// function* - ключевое слово для функции-генератора

// При вызове функции-генераторы изначально не выполняют свой код, а возвращают итератор особого типа - генератор. Когда значение потребляется путем вызова следующего метода генератора, функция Generator выполняется до тех пор, пока не встретит ключевое слово yield.

// Функцию можно вызывать столько раз, сколько необходимо, и каждый раз она возвращает новый генератор. Каждый генератор может быть повторен только один раз.

// Адаптируем приведенный выше пример. Поведение этого кода идентично, но его реализацию гораздо проще писать и читать.
function* makeRangeIterator(start = 0, end = Infinity, step = 1) {
  let count = 0;
  for (let i = start; i < end; i += step) {
    count++;
    yield i; // помещает значение i в value
  }
  return count;
}

const iter = makeRangeIterator(1, 10, 2); // получаем генератор
console.log(iter); //=> Object [Generator] {}

let res = iter.next();
console.log(res); //=> { value: 1, done: false }
while (!res.done) {
  console.log(res.value); //=> 1 3 5 7 9
  res = iter.next();
}
console.log(res); //=> { value: 5, done: true }
console.log(res.value); //=> 5


// Пример генератора выводящего таблицу умножения
function* generator(a) { // параметр a - это число для которого выводим таблицу умножения
  let b = 0; // это множитель
  for (let i = a; i < Infinity; i++) {
    yield `${a} x ${b} = ${a * b}`;
    b++;
  }
}

const gen = generator(1);
gen.next();       //=> { value: '1 x 0 = 0', done: false }
gen.next().value; //=> '1 x 1 = 1'
gen.next().value; //=> '1 x 2 = 2'
gen.next().value; //=> '1 x 3 = 3'
gen.next().value; //=> '1 x 4 = 4'
gen.next().value; //=> '1 x 5 = 5'


// Генератор фибоначе просто при помощи замыкания, без спец штук
function genfib(){
  let a = [0, 1];
  return function fib(){
    a.push(a[a.length-1] + a[a.length-2]);
    return a[a.length-3];
  }
}
let fib = genfib();
console.log(fib()); //=> 0
console.log(fib()); //=> 1
console.log(fib()); //=> 1
console.log(fib()); //=> 2













//
