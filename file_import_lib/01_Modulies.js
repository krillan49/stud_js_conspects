//                                                  Модули

// JS модули - нужны чтобы делать экспорт и импорт, чтобы подключать разные фаилы друг в друга

// Браузерне поддерживает модули по умолчанию, но можно использовать сборщики, чтобы собрать все в 1 фаил для исполнения
// Node.js поддерживает модули по умолчаию

// JS файлы автоматом оборачиваются в модуль, в новом синтаксе это идёт под капотом

// CommonJS - формат подходит чтобы использовать с Node.js, например в локальном окружении, не подходит для браузера
// ES6 Modulies - формат подходит для сборки, чтобы использовать ее в браузере



//                                              CommonJS модули

// 1. import - чтобы подключить какой-то фаил в текущий, нужно использовать команду require. Так можно подключать: встроенные утилиты nodeJS (nodeJS utils); пакеты с репотория npm (npm pakeges); свои кастомные модули (custom modules)

// a) nodeJS utils. Для подключения встроенной утилиты понадобится переменная, в которую будет сделан импорт через require. В параметры дстаточно передать строку с именем утилиты
const fs = require('fs'); // подключаем в переменную встроенную утилиту nodeJS 'fs' для работы с фаилами
console.log(fs); //=> вернет объект с кучей функций

// b) npm pakeges. Для подключения пакетов с репозитория npm нужен инициализированный фаил `package.json`, тогда мы сможем установить через команду, например Реакт `$ npm install react`, тогда появятся зависимость которая попадет в папку `node_modules` в нашем проекте и удет можно импортировать тем же способом что и в nodeJS utils
const React = require('react'); // тк путь не указан то спева будет искато в `nodeJS utils` и если не найдет тогда будет искать пакет в папке `node_modules` и тогда уже если не найдет, то выдаст ошибку
console.log(React);

// c) custom modules. Если подключаем свои модули(свои фаилы) то сперва нужно будет сделать экспорт этого фаила и только потом его подключить. При подключении своего модуля обязательно указывать путь.
const hello = require('./test2'); // подключаем test2.js по относительному пути


// 2. export:

// a) module.exports - позволяет экспортировать какую-то сущность, как ключ в передаваемом объекте (переменную, функцию, класс), импортируем объект в другой фаил и вызываем от него функцию
// test2.js (фаил из которого экспортируем):
function sayHello() {
  console.log('hello');
}
module.exports = { sayHello }; // передаем функцию по ее имени как ключ в объекте. Перезаписываем объект module.exports
// test1.js (фаил в который импортируем):
const hello = require('./test2');
console.log(hello); //=> { sayHello: [Function: sayHello] }
hello.sayHello();   //=> 'hello'

// b) Можно при импорте сразу сделать деструктуризацию объекта, чтобы вызывать без привязки к объекту
const { sayHello } = require('./test2');
sayHello(); //=> 'hello'

// c) Переменные
// В фаиле из которого экспортируем, например file1.js
module.exports = {
  foo: 'bar'
};
// В фаиле в который импортируем, например file2.js
const data = require('./file1');
console.log(data.foo); //=> bar

// d) Можно сразу экспортировать просто функцию (или класс) без объекта, например если надо экспортировать только 1 функцию (или класс). Тоесть перезаписываем module.exports и там вместо объекта будет просто функция
// test2.js:
module.exports = () => {
  console.log('hello');
};
// test1.js:
const hello = require('./test2');
console.log(hello); //=> [Function (anonymous)]
hello(); //=> 'hello'

// e) exports.ключ = - так можно присваивать функции под заданными ключами в module.exports объект. Через этот синтаксис нельзя передавать функции и классы без объекта
// test2.js:
exports.hello = function sayHello() { // exports передает функцию в объект module.exports
  console.log('hello');
}
// test1.js:
const hello = require('./test2');
console.log(hello); //=> { hello: [Function: sayHello] }



//                                                ES6 модули

// https://www.youtube.com/watch?v=r1JjvJmRvTI

// ES6 модули предполагают сборку, тк мы планируем передать в браузер 1 жс-фаил, который нужно собрать из фсех фаилов связанных экспортами и импортами.
// Сборка производится сборщиком, например Parcel.js, команды для которого нужно прописать в подраздел `scripts` в `package.json`, далее просто запускаем нужный скрипт, например `npm start`, парсер создает локальный вебсервер, делает сборку, подключает ее в заданный html-фаил(куда подключены фаилы со скриптами)
// В html файле, в скрипте js файла нужно добавить type="module" иначе будет ошибка

// import - ключевое слово для импорта из ES6 модуля. Обычно импорты прописываются в самом начале фаила

// export - ключевое слово для экспорта в ES6 модули, может иметь дополнительное ключевое слово `default`.
// export default - экспорт по умоланию, может быть максимум 1 на фаил
// export (без `default`) - когда делаем просто `export` то в переменную при импорте получаем объект. Может быть сколько угодно на 1 фаил.

// 1. Экспортируем и импортируем все содержимое фаила
// test2.js:
export default function sayHello() { // просто пишем ключевое слово `export` или `export default` перед функцией
  console.log('hello');
}
// test1.js:
import hello from './test2'; // указываем относительный путь к фаилу из которого импортируем, либо имя библиотеки
// импортируем все содержимое этого фаила, тоесть весь его код исполнится, если он там есть, например если там вызываются методы, а в переменную передается только функция на которой стоит export default
// hello - переменную для дефолта можно называть как угодно

// 2. Если просто нужно исполнить код из импортируемого фаила и никакие функции оттуда использовать не будем, то можно не указывать переменную
import './test2';

// 3. Когда делаем просто `export` то в переменную при импорте получаем объект, соответсвенно можно произвести его декомпозицию
// test2.js:
export function sayHello() { //
  console.log('hello');
}
export function greting() { // экспортируем еще функцию
  console.log('greting');
}
// test1.js:
import { sayHello, greting } from './test2'; // подгружаем несколько функций через декомпозицию объекта
sayHello(); //=> 'hello'
greting(); //=> 'greting'

// 3a. Экспорт переменной из фаила, например file1.js, чтобы ее можно было передать в другие фаилы
export const foo = 'bar';
// Импорт экспортированной переменной в фаил, например в file2.js
import { foo } from 'src/components/file1';
console.log(foo); //=> bar

// 4. Одновременно можно использовать `export` и `export default`, тогда в импорте можно одновременно в переменную принять функцию из `export default` и произести дкомпозицию объекта из `export`
// test2.js:
export default function sayHello() { //
  console.log('hello');
}
export function greting() { // экспортируем еще функцию
  console.log('greting');
}
// test1.js:
import hello, { greting } from './test2'; //
hello();   //=> 'hello'
greting(); //=> 'greting'

// 5. Если есть конфликт имен, то в строке импорта можно дать методу певдоним при помощи `as` либо `:`
import { method1 : some, method2 as twoSome } from './file.js';
some();
twoSome();

// 6. Можно импортировать все что есть в экспортирте в объект при помощи `*`
import * as some from './file.js'; //=> импортируем весь экспорт обернутый в объект some
some.method(); // соответсвенно вызываем от этого объекта

// 7. Импорт можно исппользовать так же как функцию. Тогда импорт получается динамическим и возвращает промис, который должен обрабатываться через then-нотацию или ассинхронные функции
import('./test2').then((module) => console.log(module));

// 8. re-export - в некторых случаях организуют слишком много js-фаилов и тогда гдето в корне создается index.js и в нем делают так называемый re-export
export { bay } from './file'; //
export { hello, greting } from './file2';
// Тоесть этот синтаксис сперва делает импорты из выбранных фаилов (там в соотв фунциях должен быть прописан export), а потом экспортирует.
// Далее при импорте мы можем уже обращаться к фаилу index.js или даже просто к папке в которой он лежит
import { bay, hello, greting } from './components';











//
