//                                             Регулярки

// Объект RegExp может создавать регулярные выражения, используемые для сопоставления определенного содержимого строки.

// Есть 2 способа создать новое регулярное выражение:
var reg1 = new RegExp("abc") // удобно использовать с переменными
var reg2 = /abc/
console.log(reg1,reg2)  //=> /abc/ /abc/
console.log(typeof reg2) //=> object

// Флаги:
new RegExp("abc","g");
/abc/g;
// g - глобальное соответствие
// i - игнорировать регистр
// m - многострочное совпадение
// u - Юникод
// y - прикрепленный



//                                       Методы экземпляра регулярок

// метод Object RegExp: test(). Он используется для проверки того, соответствует ли строка объекту RegExp. Он возвращает логическое значение: true/false
/a/.test("abc");  //=> true
/ab/.test("abc");  //=> true
/ac/.test("abc");  //=> false

/^a.c$/.test("abc");   //=> true
/^a.c$/.test("abbc");  //=> false



//                                 Специальные строковые методы для регулярок

// 1. match() -  когда результатов сопоставления больше одного, выходные данные представляют собой массив строк, содержащий все результаты сопоставления; Если результат сопоставления один, выходные данные представляют собой список, содержащий совпадающую строку, соответствующий индекс и исходную строку. Если результата совпадения нет, вывод будет null.
var str = "ABABCDEababcde";
str.match(/a/)    //=> [ 'a', index: 7, input: 'ABABCDEababcde' ]
str.match(/a/i)   //=> [ 'A', index: 0, input: 'ABABCDEababcde' ]
str.match(/a/ig)  //=> [ 'A', 'A', 'a', 'a' ]
str.match(/ab/)   //=> [ 'ab', index: 7, input: 'ABABCDEababcde' ]
str.match(/ab/i)  //=> [ 'AB', index: 0, input: 'ABABCDEababcde' ]
str.match(/ab/ig) //=> [ 'AB', 'AB', 'ab', 'ab' ]
str.match(/xyz/)  //=> null
str.match(/./)  //=> [ 'A', index: 0, input: 'ABABCDEababcde', groups: undefined ]
str.match(/.../g) //=> [ 'ABA', 'BCD', 'Eab', 'abc' ]

// считаем число совпадений
str.match(new RegExp('ab',"ig")).length; //=> 4
(str.match(new RegExp('xyz')) || []).length; //=> 0  // тк при отсутсвии совпадений length применился бы null



//                          Общие строковые методы которые так же могут использовать регулярки

// 1. search()
var str = "ABCDEabcde";
str.search(/abc/)  //=> 5  // аналогично str.search("abc")
str.search(/cde/)  //=> 7  // аналогично str.search("cde")
str.search(/abc/i) //=> 0
str.search(/cde/ig) //=> 2 // search() не поддерживает флаг «g»


// 2. replace()  позволяет использовать «i» и «g»
var str = "Hello World! Hello CodeWars!";
str.replace(/world/, "javascript") //=> Hello World! Hello CodeWars!   // Нет совпадений
str.replace(/world/i,"Javascript") //=> Hello Javascript! Hello CodeWars!
str.replace(/Hello/g,"I love") //=> I love World! I love CodeWars!  // "g" применяет замену к каждому "Hello"

var str = "abcabc";
str.replace(/^a/,"A")  //=> Abcabc
str.replace(/^./,"A")  //=> Abcabc
str.replace(/c$/,"C")  //=> abcabC
str.replace(/.$/,"C")  //=> abcabC

// Принимает стрелочную функцию 2м параметром
"my name is John".replace(/\b./g, x => x.toUpperCase()); //=> My Name Is John.


// 3. split()  По умолчанию используется опция «g», независимо от того, указали вы ее или нет
var str = "ababaBa"
str.split(/b/)   //=> [ 'a', 'a', 'aBa' ]
str.split(/b/i)  //=> [ 'a', 'a', 'a', 'a' ]



//                                 Жадные и нежадные соответсвия при помощи ?

var s = "100001,111,12222221,222,3333,12321,14441";
// По умолчанию соответсвие жадное, тоесть выбирает соотв максимальной длинны
s.match(/1.*1/g);  //=> [ '100001,111,12222221,222,3333,12321,14441' ]
s.match(/1.+1/g);  //=> [ '100001,111,12222221,222,3333,12321,14441' ]
// Способ сделать соотв не жадными, тоесть останавливающимися при соответсвии
s.match(/1.*?1/g);  //=> [ '100001', '11', '1,1', '1,222,3333,1', '1,1' ]
s.match(/1.+?1/g);  //=> [ '100001', '111', '12222221', '12321', '14441' ]



//                                          () - подвыражения

// Использование () может превратить регулярное выражение в подвыражение как часть сложного регулярного выражения

var str="good wood food cat bat hat";
str.match(/(g|w|f)ood/g); //=> [ 'good', 'wood', 'food' ]
str.match(/((g|w|f)ood)|((c|b|h)at)/g); //=> [ 'good', 'wood', 'food', 'cat', 'bat', 'hat' ]

var str="ababcdcd";
str.match(/(ab)?(cd)*/g);  //=> [ 'ab', 'abcdcd', '' ]
str.match(/(ab)?(cd)+/g);  //=> [ 'abcdcd' ]



//                                               (?:), (?=) and (?!)

// (?:) если не нужна обратная ссылка

// определяет подвыражения, которое не используется для обратной ссылки.
"abb aba".match(/\b(a)(\w)\1\b/g)  //=> [ 'aba' ] // тут \1  — это обратная ссылка из (a)
"abb aba".match(/\b(?:a)(\w)\1\b/g)  //=> [ 'abb' ] // а тут \1  — это обратная ссылка из (\w). (?:a) сообщает компилятору, что подвыражение не нужно сохранять, что помогает сократить работу кода

// подвыражение в выводе сщщтветсвия:
"dogs cats".match(/\b\w+(?:s|ar)\b/g) //=> [ 'dogs', 'cats' ] // c флагом g никаких отличий
// но без флага g
"dogs cats".match(/\b\w+(s|ar)\b/) //=> [ 'dogs', 's', index: 0, input: 'dogs cats'] // сохраняет результат подвыражения
"dogs cats".match(/\b\w+(?:s|ar)\b/) //=> [ 'dogs', index: 0, input: 'dogs cats' ] // не сохраняет результат подвыражения


// (?=) и (?!). регулярные выражения имеют четыре типа утверждений: положительное утверждение просмотра вперед, отрицательное утверждение просмотра вперед, положительное утверждение просмотра назад, отрицательное утверждение просмотра назад. Но в JS только два вида:
// (?=) — положительное утверждение
// (?!) — отрицательное утверждение
// Они противоположны. Их можно размещать в начале «Просмотр вперед» или в конце регулярного выражения «Просмотр назад».
var str = "javascript coffeescript"
str.match(/\b\w+script\b/g)  //=> [ 'javascript', 'coffeescript' ]
str.match(/(?=java)\b\w+script\b/g))  //=> [ 'javascript' ] // (?=java) только те соответсвия у которых в начале есть 'java'
str.match(/(?!java)\b\w+script\b/g))  //=> [ 'coffeescript' ] // (?!java) только те соответсвия у которых в начале нет 'java'
// Если они помещены в конец регулярного выражения, это не означает «должно заканчиваться на...» или «не должно заканчиваться на...», это означает «от этой позиции направо должно быть...» и «от этой позиции направо не должно быть...» тоесть должны идти до/после, но не обязательно быть частью результата самой регулярки до (?).
var str="dog,cat,pig,cow"
str.match(/\b\w+\b/g)  //=> [ 'dog', 'cat', 'pig', 'cow' ]
str.match(/\b\w+\b(?=,cat|,pig)/g)  //=> [ 'dog', 'cat' ]
str.match(/\b\w+\b(?!,cat|,pig)/g)  //=> [ 'pig', 'cow' ]
str.match(/(?=c)\b\w+\b(?!,cat|,pig)/g)  //=> [ 'cow' ]



//                                         Экранирование спецсимволов. Обратные ссылки

// Большинство специальных символов в [ ] потеряют особое значение только от своего имени
"(a*b+c?)|(.)".match(/[*+?.|()]/g); //=> [ '(', '*', '+', '?', ')', '|', '(', '.', ')' ]
// Но некоторые специальные символы, так сопоставить не получится, например \ ^ или некоторые непечатаемые символы. Тогда нужно использовать экранирующий \ перед ними
// \\   matches \
// \^   matches ^
// \f   matches Form-feed character.
// \n   matches Newline character.
// \r   matches Carriage-return character.
// \t   matches Tab character.
// \v   matches Vertical tab character.


// Второе использование \ - для формирования многосимвольного метасимвола:
// \d Соответствует цифровому символу. Эквивалентно [0-9].
// \D Соответствует нецифровому символу. Эквивалентно [^0-9].
// \w Соответствует любым буквам, цифрам и подчеркиванию. Эквивалент [A-Za-z0-9_].
// \W Соответствует любому символу, кроме букв, цифр и подчеркивания. Эквивалентно [^A-Za-z0-9_].
// \s Соответствует любому символу пробела. Эквивалентно [\f\n\r\t\v].
// \S Соответствует любому символу без пробелов. Эквивалентно [^\f\n\r\t\v].
// \b Соответствует границе слова; то есть позиция между словом и пробелом.
// \B Соответствует слову, не имеющему границы.


// Третье и четвёртое использование \ — это обратная ссылка и восьмеричный переход. Все они используют формат \num (номер — это число с одной или двумя цифрами). В зависимости от среды использования регулярные выражения будут определять его значение.
// Если \num предшествует хотя бы число захваченных подвыражений, \num является обратной ссылкой. В противном случае \num является восьмеричным escape-значением (цифры num должны быть восьмеричными цифрами (0–7)).

// пример обратной ссылки:
"food foot green glass".match(/(.)\1/g) //=> [ 'oo', 'oo', 'ee', 'ss' ]
// соответствует любым двум одинаковым последовательным символам. Следует отметить, что если вы хотите использовать обратную ссылку, вы должны определить соответствующие подвыражения с помощью ( ). Если вы определяете более одного подвыражения, \1 представляет первое подвыражение, \2 представляет второе подвыражение и т. д.
"abba baab green glass roof".match(/(.)(.)\2\1/g)  //=> [ 'abba', 'baab' ]















//
