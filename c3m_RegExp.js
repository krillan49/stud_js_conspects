//                                               RegExp

// Объект RegExp может создавать регулярные выражения, используемые для сопоставления содержимого строки.

// Есть 2 способа создать новое регулярное выражение:
let reg1 = new RegExp("abc") // удобно использовать переменные в параметре
let reg2 = /abc/
console.log(reg1, reg2)  //=> /abc/ /abc/
console.log(typeof reg2) //=> object

// Флаги:
new RegExp("abc","g");
/abc/g;
// g - глобальное соответствие
// i - игнорировать регистр
// m - многострочное совпадение
// u - Юникод
// y - прикрепленный



//                                       Методы экземпляра регулярок

// метод Object RegExp: test(). Он используется для проверки того, соответствует ли строка объекту RegExp. Возвращает логическое значение: true/false. Не применяет флаг "g"
/ab/.test("abc");  //=> true
/ac/.test("abc");  //=> false
/^a.c$/.test("abc");   //=> true
/^a.c$/.test("abbc");  //=> false



//                                  Специальные методы строк только для регулярок

// 1. match() -  когда результатов сопоставления больше одного, выходные данные массив строк, содержащий все результаты; Если результат один, выходные данные это список, содержащий совпадающую строку, соответствующий индекс и исходную строку. Если результата совпадения нет, вывод будет null.
let str = "ABABCDEababcde";
str.match(/ab/)   //=> [ 'ab', index: 7, input: 'ABABCDEababcde' ]
str.match(/ab/i)  //=> [ 'AB', index: 0, input: 'ABABCDEababcde' ]
str.match(/ab/ig) //=> [ 'AB', 'AB', 'ab', 'ab' ]
str.match(/xyz/)  //=> null
str.match(/./)    //=> [ 'A', index: 0, input: 'ABABCDEababcde', groups: undefined ]
str.match(/.../g) //=> [ 'ABA', 'BCD', 'Eab', 'abc' ]

// с применением группировки
"is (555) 867-5309".match(/\((\d+)\)/);    //=> ['(555)', '555', index: 3, input: 'is (555) 867-5309', groups: undefined ]
"is (555) 867-5309".match(/\((\d+)\)/)[1]; //=> '555'
'abbc'.match(/(.)\1/)[1];                  //=> 'b' // найти 2йной символ идущий подряд

// считаем число совпадений
str.match(new RegExp('ab',"ig")).length; //=> 4
(str.match(new RegExp('xyz')) || []).length; //=> 0  // тк при отсутсвии совпадений length применился бы null



//                            Методы строк которые могут использовать регулярки

// 1. search() - возвращает индекс совпадающей подстроки слева. Не поддерживает флаг «g»
"ABCDEabcde".search(/abc/)   //=> 5  // аналогично str.search("abc")
"ABCDEabcde".search(/abc/i)  //=> 0


// 2. replace() - заменяет совпадающие подстроки на параметр, может принимать функции, позволяет использовать «i» и «g»
let str = "Hello World! Hello CodeWars!";
str.replace(/world/, "javascript") //=> "Hello World! Hello CodeWars!"       // Нет совпадений
str.replace(/world/i,"Javascript") //=> "Hello Javascript! Hello CodeWars!"
str.replace(/Hello/g,"I love")     //=> "I love World! I love CodeWars! "     // "g" применяет замену к каждому "Hello"
"abcabc".replace(/^./,"A")         //=> Abcabc
"abcabc".replace(/c$/,"C")         //=> abcabC

// Принимает стрелочную функцию 2м параметром для изменения элементов замены
"my name is John".replace(/\b./g, x => x.toUpperCase()); //=> "My Name Is John"


// 3. split() - делит строку по указанной подстроке. По умолчанию используется опция «g», те не обязательно ее указывать.
"ababaBa".split(/b/);                    //=> [ 'a', 'a', 'aBa' ]
"ababaBa".split(/b/i);                   //=> [ 'a', 'a', 'a', 'a' ]
[-1,6,-2,3,5,-7].join(' ').split(/-\d/); //=> [ '', ' 6 ', ' 3 5 ', '' ]



//                                   Нежадные соответсвия при помощи '?'

let s = "100001_111_12222221_222_3333_12321_14441";
// По умолчанию соответсвие жадное, тоесть выбирает соответсвие максимальной длинны
s.match(/1.*1/g);  //=> [ '100001_111_12222221_222_3333_12321_14441' ]
s.match(/1.+1/g);  //=> [ '100001_111_12222221_222_3333_12321_14441' ]

// Способ сделать соответсвия не жадными, тоесть останавливающимися при соответсвии
s.match(/1.*?1/g);  //=> [ '100001', '11', '1_1', '1_222_3333_1', '1_1' ]
s.match(/1.+?1/g);  //=> [ '100001', '111', '12222221', '12321', '14441' ]



//                                         Экранирование спецсимволов

// Большинство специальных символов в [ ] потеряют свое особое функциональное значение
"(a*b+c?)|(.)".match(/[*+?.|()]/g); //=> [ '(', '*', '+', '?', ')', '|', '(', '.', ')' ]

// Но некоторые специальные символы, так сопоставить не получится, например "\", "^" или некоторые непечатаемые символы. Тогда нужно использовать экранирующий "\" перед ними:
// \\   matches \
// \^   matches ^
// \f   matches Form-feed character.
// \n   matches Newline character.
// \r   matches Carriage-return character.
// \t   matches Tab character.
// \v   matches Vertical tab character.

// Второе использование \ - для формирования многосимвольного метасимвола:
// \d   цифровому символу.                                Эквивалентно [0-9].
// \D   нецифровому символу.                              Эквивалентно [^0-9].
// \w   любым буквам, цифрам и подчеркиванию.             Эквивалент [A-Za-z0-9_].
// \W   любому символу, кроме букв, цифр и подчеркивания. Эквивалентно [^A-Za-z0-9_].
// \s   любому символу пробела.                           Эквивалентно [\f\n\r\t\v].
// \S   любому символу без пробелов.                      Эквивалентно [^\f\n\r\t\v].
// \b   граница слова;                                    тоесть позиция между словом и пробелом.
// \B   слово, не имеющему границы.


// Третье и четвёртое использование \ — это обратная ссылка и восьмеричный переход. Они оба используют формат \num (num — это число с одной или двумя цифрами). В зависимости от среды использования регулярные выражения будут определять его значение.
// Если \num предшествует хотя бы число захваченных подвыражений, \num является обратной ссылкой. В противном случае \num является восьмеричным escape-значением (цифры num должны быть восьмеричными цифрами (0–7)).



//                                            () - подвыражения

// Использование () может превратить регулярное выражение в подвыражение как часть сложного регулярного выражения
"good wood food cat bat hat".match(/(g|w|f)ood/g);               //=> [ 'good', 'wood', 'food' ]
"good wood food cat bat hat".match(/((g|f)ood)|((c|h)at)/g);     //=> [ 'good', 'food', 'cat', 'hat' ]
"ababcdcd".match(/(ab)?(cd)*/g);                                 //=> [ 'ab', 'abcdcd', '' ]
"ababcdcd".match(/(ab)?(cd)+/g);                                 //=> [ 'abcdcd' ]



//                                              Обратные ссылки

// \n (n — число с одной или двумя цифрами) - являются обратными ссылками, если им предшествует хотябы одно подвыражение (). Если есть более одного подвыражения, \1 первое подвыражение, \2 второе подвыражение итд.

"food foot green glass".match(/(.)\1/g); //=> [ 'oo', 'oo', 'ee', 'ss' ] // соответ двум одинаковым последовательным символам.
"abba baab green glass roof".match(/(.)(.)\2\1/g);  //=> [ 'abba', 'baab' ] // соотв 2м символам и их реверсу

// В параметрах для замены подвыражение записывается через синтаксис "$n" вместо "\n"
"is (555) 867-5309".replace(/.*\((\d+)\).*/, "\1");  //=>       // синтаксис "\n" не работает в параметре замены
"is (555) 867-5309".replace(/.*\((\d+)\).*/, "$1")); //=> 555
'346791234567'.replace(/(.{2})/g, '$1 '); //=> '34 67 91 23 45 67 '  // вставка каждого отдельного совпадения



//                                               (?:), (?=), (?!)

// ?: - префикс для подвыражения, определяет подвыражение, которое не используется для обратной ссылки.
"abb aba".match(/\b(a)(\w)\1\b/g)    //=> [ 'aba' ]   //  тут \1  —  обратная ссылка из (a)
"abb aba".match(/\b(?:a)(\w)\1\b/g)  //=> [ 'abb' ]   // а тут \1  — это обратная ссылка из (\w). Тоесть (?:a) сообщает компилятору, что подвыражение не нужно сохранять

// подвыражение в выводе соответсвия:
"dogs car".match(/\b\w+(?:s|ar)\b/g) //=> [ 'dogs', 'car' ] // c флагом g никаких отличий
"dogs car".match(/\b\w+(s|ar)\b/)   //=> [ 'dogs', 's', index: 0, input: 'dogs car'] // сохраняет результат подвыражения
"dogs car".match(/\b\w+(?:s|ar)\b/) //=> [ 'dogs', index: 0, input: 'dogs car']      // не сохраняет результат подвыражения


// (?=) и (?!). Pегулярные выражения имеют четыре типа утверждений: положительное утверждение просмотра вперед, отрицательное утверждение просмотра вперед, положительное утверждение просмотра назад, отрицательное утверждение просмотра назад.
// Но в JS есть только два вида:
// (?=) — положительное утверждение
// (?!) — отрицательное утверждение
// Они противоположны. Их можно размещать в начале «Просмотр вперед» или в конце регулярного выражения «Просмотр назад».
let str = "javascript coffeescript"
str.match(/\b\w+script\b/g)           //=> [ 'javascript', 'coffeescript' ]
str.match(/(?=java)\b\w+script\b/g))  //=> [ 'javascript' ] // только те соответсвия перед которыми есть 'java'
str.match(/(?!java)\b\w+script\b/g))  //=> [ 'coffeescript' ] // (?!java) только те соответсвия перед которыми нет 'java'
// Если они помещены в конец регулярного выражения, это не означает «должно заканчиваться на...» или «не должно заканчиваться на...», это означает «от этой позиции направо должно быть...» и «от этой позиции направо не должно быть...».
let str="dog,cat,pig,cow"
str.match(/\b\w+\b/g)  //=> [ 'dog', 'cat', 'pig', 'cow' ]
str.match(/\b\w+\b(?=,cat|,pig)/g)  //=> [ 'dog', 'cat' ]
str.match(/\b\w+\b(?!,cat|,pig)/g)  //=> [ 'pig', 'cow' ]
str.match(/(?=c)\b\w+\b(?!,cat|,pig)/g)  //=> [ 'cow' ]
















//
