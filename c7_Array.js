//                                               Массивы

// В js нет строгого типизирования и массивы можно заполнять любыми типами данных вперемешку, как и в Руби

var some = new Array(); // Создание пустого массива через имя класса(массив экземпляр класса ??)
some[0] = '1'; // Добавление элемента // В массивах отсчет начинается с 0.
some[1] = 2;
some[4] = 66;
some.push("codewars") // Добавление элемента в конец при помощи метода push
some.push("a", 'b') // можно добавить несколько элементов
console.log(some);    //=> [ '1', 2, <2 empty items>, 66, 'codewars', 'a', 'b' ]
console.log(some[0]); //=> '1' Вывод первого элемента
console.log(some[2]); //=> undefined

var some2 = []; // упрощенное создание массива

var array = new Array(1, 5, 2); // Создание массива со значениями

var arr = [5, true, 'stroka', 5.7, 0, -100]; // упрощенное создание массива со значениями
console.log(arr);    //=> [ 5, true, 'stroka', 5.7, 0, -100 ] // в консоли разработчика хром массив выводится в строку так же можно его развернуть за доп инфой
arr[3] = 'word';     // изменяем элемент массива
console.log(arr);    //=> [ 5, true, 'stroka', 'word', 0, -100 ]


// Нет отрицательных индексов ??



//                                                Фичи

[] == [] //=> false
[] === [] //=> false
[1, 2] == [1, 2] //=> false
[1, 2] === [1, 2] //=> false

console.log([...5678+[]]); //=> [ '5', '6', '7', '8' ]

Array(5).fill('a') //=> [ 'a', 'a', 'a', 'a', 'a' ]



//                                                in

2 in [1, 2, 3] //=> true
5 in [1, 2, 3] //=> false

// есть какието проблемы в условиях с отрицанием



//                                            Методы массивов

// Опрределение массив ли данный объект статическим методом массива
Array.isArray([1, 3, 5]); //=> true
Array.isArray('[]'); //=> false
Array.isArray(new Array(5)); //=> true
Array.isArray(new Int16Array([15, 33])); //=> false

// Сложение массивов
var arr1 = [1,2], arr2 = [3,4];
[...arr1, ...arr2]; //=> [1,2,3,4]
['a', 'b'].concat(['c', 'd']);  //=> [ 'a', 'b', 'c', 'd' ]
// Можно прибавить к массиву любые типы данных и они поместятся в массив
['a', 'b'].concat('c', 5, [1, 'd'], [[6], [7]]);  //=> [ 'a', 'b', 'c', 5, 1, 'd', [ 6 ], [ 7 ] ]

// Можно использовать для разглаживания массивов(разглаживает только 1 вложенность)
[].concat(...[[1,2],[3,4],[5,6]]); //=> [ 1, 2, 3, 4, 5, 6 ]
// Полное разглаживание через перевод в строку
([1, [2, ['pig', 3]]] + '').split(',') //=> [ '1', '2', 'pig', '3' ]

// Клонирование массивов(тк мутируют и не клонируются итераторами, например sort)
var a1 = [...arr], a2 = [...arr];


var elements = new Array(23, 6, 0, true, "П");
console.log(elements.length); //=> 5  Выводит длинну массива
elements.reverse();           //=> ["П", true, 0, 6, 23]  перевернуть массив
elements.pop();               //=> "П" // удаляет последний эллемент из массива и возвращает его
elements.slice(0, 2);         //=> [23, 6] // 1й параметр индекс, 2й число элементов
elements.includes(6);         //=> true

['A', 'b', 'c'].join('-')     //=> 'A-b-c'
['A', 'b', 'c'].join()        //=> 'A,b,c'  // без аргумента объединяет запятыми
["1","2","3","4","5"].toString();       //=> '1,2,3,4,5' // аналог join()
JSON.stringify(["1","2","3","4","5"]);  //=> '["1","2","3","4","5"]'  // более производительный варик
[[1,2],[3,4],[5]].toString();       //=> '1,2,3,4,5'
JSON.stringify([[1,2],[3,4],[5]]);  //=> '[[1,2],[3,4],[5]]'

[2,3,5,7,11,5].indexOf(5);      //=> 2
[2,3,5,7,11,5].indexOf(99);      //=> -1
['a', 'b', 'c', 'd', 'b'].indexOf('b', 2); //=> 4
[2,3,5,7,11,5].lastIndexOf(5); //=> 5
['a', 'b', 'c', 'd', 'b'].lastIndexOf("b",2); //=> 1

// Срезы(срезы с 2мя значениями изменяют исходный массив как pop)
[ 5, 6, 7, 8 ].splice(-2,2); //=> [ 7, 8 ] // от индекса -2 вправо 2 элемента включая его

// Странный sort // изменяют массив(только с функцией ??)
[9, 3, 12, 11, 40, 28, 5].sort();                            //=> [11, 12, 28, 3, 40, 5, 9]; сортирует как строки
[140000, 104, 99].sort(function (a, b) {  return a - b;  }); //=> [99, 104, 140000]; сортирует нормально
[140000, 104, 99].sort((a, b) => a - b);                     //=> [99, 104, 140000]  // соотв b - a будет по убыванию
[{"k": 1, "n": 3},{"k": 3, "n": 2}].sort((a, b) => b['k'] - a['k']); //=> [ { k: 3, n: 2 }, { k: 1, n: 3 } ]



//                                               Итераторы??

[1,4,9].forEach(x => console.log(x + 1)) //=> 2 5 10 // не меняет массив

var r = 0;
[1,2,3,4,5].forEach(x => r += x**2)
console.log(r); //=> 55

list.forEach(d=>{ // фигурные скобки если много строк ??
  if(orders[d.meal]) orders[d.meal]++;
  else orders[d.meal] = 1;
});

[1,4,9].map(Math.sqrt);  //=> [1,2,3]
[ '5', '6', '7', '8' ].map(Number); //=> [ 5, 6, 7, 8 ]
[1, 2, 3].map(n => n**2) //=> [ 1, 4, 9 ]

[9, 3, 12, 11, 40, 28, 5].filter(num => num > 10); //=> [ 12, 11, 40, 28 ]  // аналог select в Руби

[9, 3, 12, 11, 40, 28, 5].every(e => e > 0); //=> true     // аналог all? в Руби

[1, 2, 3, 4, 5].reduce((sum, n) => sum + n, 0); //=> 15
[1, 2, 3, 4, 5].reduce((multi, n) => multi * n, 1); //=> 120
[[1, 2], [3, 4]].reduce((multi, [b, c]) => multi * (b + c), 1);// => 21 // запись элементов подмассива


// Странная фигня в итераторах не работает Return
function iterFicha() {
  [1, 2, 3].forEach(n => {
    return 'Return from forEach';
  });
  return 'No';
}
console.log(iterFicha()); //=> 'No'



//                                            Многомерные массивы

// Многомерный массив - это массив, в котором каждый элемент является другим массивом. Массивы с более чем третьим уровнем вложенности очень редко используются

// Создание пустого
var symbols = new Array(new Array(), new Array());
symbols[0][1] = 'A'; // Создаем элемент подмассива

// Создание со значениями
var x = new Array(new Array(0, 34, 2), new Array(3, 4, 5));
console.log(x[0][1]); //=> 34
x[0][1] = 1; // Заменяем элемент подмассива
console.log(x[0][1]); //=> 1

// Упрощенное создание пустого
var matrix = [[], [], []];

// Упрощенное создание со значениями
var m = [
  [4, 6, 8], ['stroka', 5.7], [0, -100]
];
console.log(m); // развернув в консоли получим подробную инфу(каждый вложенный так же можно развернуть)













//
