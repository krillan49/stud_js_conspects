//                                               Массивы

// В js нет строгого типизирования и массивы можно заполнять любыми типами данных вперемешку, как и в Руби

var some = new Array(); // Создание пустого массива через имя класса(массив экземпляр класса ??)
some[0] = '1'; // Добавление элемента // В массивах отсчет начинается с 0.
some[1] = 2;
some[4] = 66;
console.log(some);    //=> [ '1', 2, <2 empty items>, 66 ]
console.log(some[0]); //=> '1' Вывод первого элемента
console.log(some[2]); //=> undefined

var some2 = []; // упрощенное создание массива

var array = new Array(1, 5, 2); // Создание массива со значениями

var arr = [5, true, 'stroka', 5.7, 0, -100]; // упрощенное создание массива со значениями
console.log(arr);    //=> [ 5, true, 'stroka', 5.7, 0, -100 ] // в консоли разработчика хром массив выводится в строку так же можно его развернуть за доп инфой
arr[3] = 'word';     // изменяем элемент массива
console.log(arr);    //=> [ 5, true, 'stroka', 'word', 0, -100 ]


// Нет отрицательных индексов ??



//                                        push(), pop(), shift(), unshift()

// Данные методы могут манипулировать только началом и хвостом массива. Их скорость относительно низкая, когда нужно иметь дело с большими данными, прямое добавление по индексу может быть быстрее
var arr = [1,2,3,4,5]

// push() - добавляет новый элемент в конец массива
arr.push(6);
arr; //=> [1,2,3,4,5,6]
arr.push(7,8);       // можно добавлять нескольно элементов
arr; //=> [1,2,3,4,5,6,7,8]

// pop() - удаляет элемент из конца массива и возвращает его
arr.pop();  //=> 8
arr;  //=> [1,2,3,4,5,6,7]

// shift() - удаляет элемент из начала массива и возвращает его.
arr.shift();  //=> 1
arr;  //=> [2,3,4,5,6,7]

//unshift() - добавляет элементы в начало массива
arr.unshift(1);
arr;  //=> [1,2,3,4,5,6,7]
arr.unshift(3,2); // можно добавить несколько элементов
console.log(arr);  //=> [3,2,1,2,3,4,5,6,7]



//                                             slice(), клон и splice()

// slice() делает срез из массива, 1й аргумент индекс включительно, 2й индекс не включительно. Не изменяет исходный массив
var arr = [1, 2, 3, 4, 5];
arr.slice(1, 3); //=> [ 2, 3 ]
arr; //=> [ 1, 2, 3, 4, 5 ]

// При помощи slice() без аргументов можно сделать клон массива
var arr = [1, 2, 3, 4, 5];
var brr = arr;
var crr = arr.slice();
console.log([arr, brr, crr]); //=> [ [ 1, 2, 3, 4, 5 ], [ 1, 2, 3, 4, 5 ], [ 1, 2, 3, 4, 5 ] ]
arr.pop()
console.log([arr, brr, crr]); //=> [ [ 1, 2, 3, 4 ], [ 1, 2, 3, 4 ], [ 1, 2, 3, 4, 5 ] ]
// днако, если исходный массив представляет собой 2D-массив или многомерный массив, использования среза() недостаточно


// splice() может добавлять и/или удалять элементы в любом месте массива. Изменяет исходный массив
var arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
var startindex = 2; // 1й аргумент индккс начала среза
var deleteCount = 3; // 2й аргумент число элементов в срезе
var el1 = 'a'; // 3й и последующие элементы будут вставлены в точке среза
var el2 = 'b';
arr.splice(startindex, deleteCount, 'a', 'b'); //=> [ 2, 3, 4 ]  // возвращает удаленный срез массива
arr; //=> [ 0, 1, 'a', 'b', 5, 6, 7, 8, 9 ]

// если не добавлять параметры 3+ то будет просто срез без добавления чего либо
var arr = [1, 2, 3, 4, 5];
arr.splice(1, 2); //=> [ 2, 3 ]
arr; //=> [ 1, 4, 5 ]

// использование для удаления 1го элемента например для удаления нечетных чисел
var arr = [1, 2, 3, 4, 5];
for (var i = arr.length-1; i >= 0; i--) { // проходим с конца чтобы при удалении индекс не менялся
  if (arr[i]%2) arr.splice(i,1)
}
console.log(arr); //=> [ 2, 4 ]



//                                            Другие методы массивов

// Опрределение массив ли данный объект статическим методом массива
Array.isArray([1, 3, 5]); //=> true
Array.isArray('[]'); //=> false
Array.isArray(new Array(5)); //=> true
Array.isArray(new Int16Array([15, 33])); //=> false

// Сложение массивов
var arr1 = [1,2], arr2 = [3,4];
[...arr1, ...arr2]; //=> [1,2,3,4]
['a', 'b'].concat(['c', 'd']);  //=> [ 'a', 'b', 'c', 'd' ]
// Можно прибавить к массиву любые типы данных и они поместятся в массив
['a', 'b'].concat('c', 5, [1, 'd'], [[6], [7]]);  //=> [ 'a', 'b', 'c', 5, 1, 'd', [ 6 ], [ 7 ] ]

// Можно использовать для разглаживания массивов(разглаживает только 1 вложенность)
[].concat(...[[1,2],[3,4],[5,6]]); //=> [ 1, 2, 3, 4, 5, 6 ]
// Полное разглаживание через перевод в строку
([1, [2, ['pig', 3]]] + '').split(',') //=> [ '1', '2', 'pig', '3' ]

// Клонирование массивов(тк мутируют и не клонируются итераторами, например sort)
var a1 = [...arr], a2 = [...arr];


var elements = new Array(23, 6, 0, true, "П");
console.log(elements.length); //=> 5  Выводит длинну массива
elements.reverse();           //=> ["П", true, 0, 6, 23]  перевернуть массив
elements.includes(6);         //=> true

['A', 'b', 'c'].join('-')     //=> 'A-b-c'
['A', 'b', 'c'].join()        //=> 'A,b,c'  // без аргумента объединяет запятыми
["1","2","3","4","5"].toString();       //=> '1,2,3,4,5' // аналог join()
JSON.stringify(["1","2","3","4","5"]);  //=> '["1","2","3","4","5"]'  // более производительный варик
[[1,2],[3,4],[5]].toString();       //=> '1,2,3,4,5'
JSON.stringify([[1,2],[3,4],[5]]);  //=> '[[1,2],[3,4],[5]]'

[2,3,5,7,11,5].indexOf(5);      //=> 2
[2,3,5,7,11,5].indexOf(99);      //=> -1
['a', 'b', 'c', 'd', 'b'].indexOf('b', 2); //=> 4
[2,3,5,7,11,5].lastIndexOf(5); //=> 5
['a', 'b', 'c', 'd', 'b'].lastIndexOf("b",2); //=> 1

// Странный sort // изменяют массив(только с функцией ??)
[9, 3, 12, 11, 40, 28, 5].sort();                            //=> [11, 12, 28, 3, 40, 5, 9]; сортирует как строки
[140000, 104, 99].sort(function (a, b) {  return a - b;  }); //=> [99, 104, 140000]; сортирует нормально
[140000, 104, 99].sort((a, b) => a - b);                     //=> [99, 104, 140000]  // соотв b - a будет по убыванию
[{"k": 1, "n": 3},{"k": 3, "n": 2}].sort((a, b) => b['k'] - a['k']); //=> [ { k: 3, n: 2 }, { k: 1, n: 3 } ]



//                                               forEach()

[1,4,9].forEach(x => console.log(x + 1)) //=> 2 5 10 // не меняет массив

var r = 0;
[1,2,3,4,5].forEach(x => r += x**2)
console.log(r); //=> 55

list.forEach(d=>{ // фигурные скобки если много строк ??
  if(orders[d.meal]) orders[d.meal]++;
  else orders[d.meal] = 1;
});



//                                                 map()

// map() - создает новый массив с результатами вызова предоставленной функции для каждого элемента этого массива.
[1, 4, 9].map(Math.sqrt);             //=> [1,2,3]
[ '5', '6', '7', '8' ].map(Number);   //=> [ 5, 6, 7, 8 ]
[1, 2, 3].map(n => n**2)              //=> [ 1, 4, 9 ]
arr.map(s=>s.slice(0,s.length/2)+"|"+s.slice(-s.length/2))  // с условием

// Синтаксис с блоком, необходим return
arr.map(s =>{
  if (s.length % 2 == 0 ){
    s = s.slice(0, s.length/2) + '|' + s.slice(s.length/2, s.length);
  } else {
    s = s.slice(0, s.length/2) + '|' + s.slice(s.length/2+1, s.length);
  }
  return s; // без этого вернет undefined
})

// with_index встроен по умолчанию, без присвоения в переменную или помещения в console.log выдает ошибку почемуто ??
var arr = [1, 2, 3].map((e,i)=>i)            //=>[ 0, 1, 2 ]
// Применение with_index для нового массива
var arr = [...Array(4)]  //=> [ undefined, undefined, undefined, undefined ]
var arr = [...Array(4)].map((_,i)=>i)          //=> [ 0, 1, 2, 3 ]
var arr = Array.prototype.map.call([...Array(4)],(_,i)=>i)   //=> [ 0, 1, 2, 3 ]

// with_object встроен по умолчанию
brr = [2,4,6,8].map((_, i, arr)=>arr[arr.length-1-i]) //=> [ 8, 6, 4, 2 ]

// zip при помощи map
var a = ['a', 'b', 'c'], b = [1, 2, 3];
a.map((e, i) => e + b[i]); //=> [ 'a1', 'b2', 'c3' ]



//                                              filter()

// filter() - метод создает новый массив со всеми элементами, прошедшими проверку, реализованную предоставленной функцией.
// filter() всегда принимает функцию в качестве параметра, функция всегда возвращает true или false.
// filter() будет работать очень медленно при работе с большими данными.

[1,2,3,4,5].filter(function(x){return x < 3});   //=> [ 1, 2 ]
[1,2,3,4,5].filter(x=> x % 2 == 0);   //=> [ 2, 4 ]
[3,6,9,12].filter(x=> x%2==0 && x%3==0);  //=> [ 6, 12 ]

// Если возвращаемое значение функции не логическое, оно будет автоматически преобразовано в логическое:
[1,2,3,4,5].filter(x=> x % 2); //=> [ 1, 3, 5 ] // x % 2 возвращает 1 или 0, автоматически преобразуется в true(1) или false(0).

// Если функция не возвращает условный оператор напрямую, а состоит из нескольких операторов, то необходимо добавить фигурные скобки.
var b=["","a","ab","aba","abab","ababa"].filter(x=>{
  if (x.length < 2) return true;
  var y = x.split("").reverse().join("");
  return x == y;
})
console.log(b)   //=> [ '', 'a', 'aba', 'ababa' ]



//                                              every()

[9, 3, 12, 11, 40, 28, 5].every(e => e > 0); //=> true     // аналог all? в Руби



//                                              reduce()

[1, 2, 3, 4, 5].reduce((sum, n) => sum + n, 0); //=> 15
[1, 2, 3, 4, 5].reduce((multi, n) => multi * n, 1); //=> 120
[[1, 2], [3, 4]].reduce((multi, [b, c]) => multi * (b + c), 1);// => 21 // запись элементов подмассива



//                                          return и итераторы

// Странная фигня в итераторах Return не работает глобально относительно функции
function iterFicha() {
  [1, 2, 3].forEach(n => {
    return 'Return from forEach';
  });
  return 'No';
}
console.log(iterFicha()); //=> 'No'



//                                                Фичи

[] == [] //=> false
[] === [] //=> false
[1, 2] == [1, 2] //=> false
[1, 2] === [1, 2] //=> false

console.log([75,,85]) //=> [ 75, <1 empty item>, 85 ]

console.log([...5678+[]]); //=> [ '5', '6', '7', '8' ]

Array(5).fill('a') //=> [ 'a', 'a', 'a', 'a', 'a' ]

// Создание нового массива из чисел от 0 и до чегото
[...Array(10).keys()] //=> [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]



//                                                in

2 in [1, 2, 3] //=> true
5 in [1, 2, 3] //=> false

// есть какието проблемы в условиях с отрицанием



//                                            Многомерные массивы

// Многомерный массив - это массив, в котором каждый элемент является другим массивом. Массивы с более чем третьим уровнем вложенности очень редко используются

// Создание пустого
var symbols = new Array(new Array(), new Array());
symbols[0][1] = 'A'; // Создаем элемент подмассива

// Создание со значениями
var x = new Array(new Array(0, 34, 2), new Array(3, 4, 5));
console.log(x[0][1]); //=> 34
x[0][1] = 1; // Заменяем элемент подмассива
console.log(x[0][1]); //=> 1

// Упрощенное создание пустого
var matrix = [[], [], []];

// Упрощенное создание со значениями
var m = [
  [4, 6, 8], ['stroka', 5.7], [0, -100]
];
console.log(m); // развернув в консоли получим подробную инфу(каждый вложенный так же можно развернуть)













//
